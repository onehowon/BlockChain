# 합의 알고리즘
## 1. PoW(Proof of Working)
### 1) 제안 자격 취득 방법 : 계산이 어려운 문제를 풀 것
### 2) 네트워크 참여 제한 : 없음
### 3) 합의에 필요한 연산량 : 높음
### 4) 위협 : 전체 연산량의 51%를 한 참여자가 소유시 중앙화 됨
### 5) 대표 블록체인 : BTC, LTC, ETH, Monero, QTM
### Ref) 지금의 블록을 가지고 해쉬를 만듦, 갈수록 노드 참여가 힘들어진다.

## 2. PoS(Proof of Stake)
### 1) 제안 자격 취득 방법 : 플랫폼 토큰을 보유한 양과 기간에 따라 결정적으로 또는 확률적으로 뽑힐 것
### 2) 네트워크 참여 제한 : 없거나 낮음
### 3) 합의에 필요한 연산량 : 낮음
### 4) 위협 : 전체 토큰의 51%를 한 참여자가 소유시 중앙화 됨
### 5) 대표 블록체인 : ETH FFG & CFG, EOS(dPOS)
### Ref) 토큰이 많은 사용자가 다음 블록의 제안권을 가짐, PoW로 경쟁을 하다가 PoS로 가려는 구조(ETH)

## 3. BFT-variants
### 1) 제안 자격 취득 방법 : 정해진 순번 또는 정해진 확률에 의해 뽑힐 것 
### 2) 네트워크 참여 제한 : 높음
### 3) 합의에 필요한 연산량 : 낮음
### 4) 위협 : 전체 참여노드의 1/3이상이 담합할 경우 합의 불가, 전체 참여 노드의 2/3 이상이 담합 시에 중앙화 됨
### 5) 대표 블록체인 :  Klaytn, Hyperledger Fabric, Ontology, Tendermint
### Ref) 클레이튼은 1초에 4000개의 Transaction을 담을 수 있음

## Nonce
### 해쉬를 하면 항상 같은 값이 나오는데 앞에 아무런 숫자를 넣으면 다른 해쉬 값이 나옴. 의미는 없지만 해쉬값을 크게 바꾸기 위한 어떤 Garbage 값
#### CPU - 해쉬를 만드는데 취약하다(고차원 연산을 하는 HW)
#### GPU - 단순한 HW, 코어가 많을 수록 연산이 빨라짐
#### Difficulty - 채굴 난이도
#### GPU 세대로 들어서면서 Difficulty 상승

# 블록체인 구분하는 정의
## 기준 1) 누구든지 기록된 정보(블록)를 자유롭게 읽을 수 있는지?
## 기준 2) 명시적 등록 또는 자격취득 없이 정보를 블록체인 네트워크에 기록할 수 있는지?
### Public : 블록체인의 정보가 공개 돼있고 네트워크가 정한 기준에 따라 정보를 기록요청할 수 있다.
### Private : 미리 자격을 득한 사용자만이 정보를 기록할 수 있다.
### Permissionless : 네트워크의 참여가 제한된 경우
### Permissioned : 그렇지 않은 경우

# 네트워크 참여의 정의
## (넓은 의미) 블록체인 P2P 네트워크에 참여
## (좁은 의미) 합의과정에 참여

# 공개키 암호화 전자서명
## 1. 암호화
### 1) 고전적 암호: 카이사르 암호
##### - 암호화 하려는 내용을 알파벳별로 일정한 거리만큼 밀어서 다른 알파벳으로 치환하는 기법

### 2) 대칭키 암호/비대칭키 암호
#### - 평문 : 암호화 되어 있지 않은 문자열
#### - 암호화 : 평문을 암호로
#### - 복호화 : 암호를 평문으로

### 암호화 / 복호화 사용키 동일 시 대칭키 암호
### 암호화 / 복호화 사용키 다를 시 비대칭키 암호

### 3) 암호화 사용되는 키 : 공개키(PK)
### 4) 복호화 사용되는 키 : 비밀키(Private Key, Secret Key, SK)
### 5) 비대칭키 암호화 목적 : 누구든지 암호화 가능하지만 비밀키 아는 사람만 복호화 가능
#### 비밀키 -> 공개키 도출 쉬움
#### 공개키 -> 비밀키 도출 어려움(암호학적으로)
#### Ref) 비대칭키 암호는 지정된 사람만 정보를 확인할 수 있도록 도움(privacy)

# 전자서명 
## 블록체인의 암호화 기법
### - 모든 노드가 같은 정보를 공유
### - 암호학적인 소유권 확인(은행은 누구에게 속하는지 알 수 있음)
#### 1) 대부분의 블록체인 주소는 공개키로부터 도출한 값
##### BTC ) Hash 160 of public key where Hash 160 = RIPEMD160 + SHA256
##### - 임의의 주소 X에 10 BTC가 있다고 가정할 때 Alice는 X에서 또 다른 임의의 주소 Y로 5 BTC를 전송하는 거래를 성사하기 위해 X로 변환되는 공개키와 짝을 이루는 비밀키로 해당 거래를 서명할 수 있어야 함
##### ETH ) Rightmost 160 bits of Keccak hash of a public key
##### - 임의의 주소 X에 위치한 어카운트 잔고에 10 ETH가 있다고 가정할 때 Alice는 X에서 또 다른 임의의 주소 Y에 위치한 어카운트로 5 ETH를 전송 하는 거래를 성사하기 위해 X로 변환되는 공개키와 짝을 이루는 비밀키로 해당 거래를 서명할 수 있어야 함

# 구현 방법으로 나눈 블록체인
## 1) UTXO (Unspent Transaction Output) 기반
### - 블록체인에 사용 가능한 토큰 - UTXO 사용 자격검증방법 기록
### - 일반적 자격검증방법은 UTXO의 정보와 일치하는 공개키로 검증가능한 전자서명을 제출
### - BTC가 대표

## 2) 어카운트 기반 블록체인
### - 어카운트는 블록체인을 구성하는 주체를 표현하며 상태 기록

## 3) ETH 어카운트 주소, 상태
### - 어카운트는 EOA(Externally Owned Account)와 스마트컨트랙트로 구분
### - ETH 사용자는 EOA 사용

## 4) 트랜잭션 : 어카운트의 행동
### - 블록체인 참여자들은 블록 검증 시 트랜잭션들이 올바른 순서대로 정렬되어있는지를 합의
### Confirmation 숫자는 트랜잭션이 블록에 포함된 이후 생성된 블록 숫자
#### ex) 임의 트랜잭션 T가 포함된 블록 높이가 100, 현재 블록 높이가 105라면 T의 con 숫자는 6

#### PoW 를 사용하는 블록체인들은 Finality가 없어서 confirmation 숫자가 중요
#### Finality란 블록의 완결성을 의미
#### - 합의를 통해 생성된 블록이 번복되지 않을 경우 완결성 존재
#### Pow 기반 합의는 확률 기반으로 경우에 따라 블록이 사라질 수도 있으므로 완결성이 부재

## BFT Based 블록체인
### - 블록의 완결성이 보장됨
### - 네트워크 동기화 때문
### - 블록생성이 PoW에 비해 빠르고 경제적
### - 정해진 네트워크에서는 굉장히 효율적
### - 네트워크 동기화 필요로 인해 참여자 숫자 제한

# Klaytn
## Klaytn BFT - 확장가능한 BFT 사용
### - PoW 자체가 비효율적인 구조
### N 개 노드 가운데 S개 부분노드 집합을 확률적으로 선택 후 전체집합을 거버넌스 카운실 부분집합을 커미티 정의
### 커미티 선택은 VRF*(Verifiable Random Function)로 구해진 무작위값 기반 매 블록마다 새 커미티 뽑아 BFT 실행

# Blockchain State(블록체인 상태)
## - 블록체인은 트랜잭션으로 변화하는 상태 기계(State Machine)

## 1) 상태 기계
### - 블록체인은 초기 상태에서 변경사항을 적용하여 최종 상태로 변화하는 상태 기계
### - 이전 블록의 최종 상태는 현재 블록의 초기 상태
### - Gen block의 경우 임의 초기값들이 설정되는데 이게 gen block의 초기상태이자 최종 상태

## - (어카운트 기반) 블록체인 상태
## - TX는 어카운트를 생성하거나 변경
### -- e.g Alice가 기존 존재하지 않던 주소 X에 1 ETH를 전송하면 새로운 EOA 생성
### -- e.g Alice가 새로운 스마트 컨트랙트를 배포(컨트랙트도 어카운트)
### -- e.g Alice가 Bob에게 5 eth를 전송하는 TX가 체결되면 Alice의 Bob의 잔고가 변경
### -- 항상 같은 결과를 보장하기 위해 하나의 TX가 반영되는 과정에서 다른 TX의 개입은 제한됨

# 1. 트랜잭션과 어카운트
## ETH 어카운트의 종류
### 1) External Account : 사용자가 사용하는 어카운트
### 2) Contract Account : 스마트 컨트랙트를 표현하는 어카운트

## ETH - EOA와 스마트 컨트랙트 상태를 기록 및 유지
### 스마트 컨트랙트 : 특정주소에 존재하는 실행 가능한 프로그램
### 프로그램은 상태를 가지기에 ETH/KLAY는 스마트컨트랙트를 어카운트로 표현
### EOA는 블록에 기록되는 TX를 생성
### 블록에 기록되는 TX들은 명시적 변경을 일으킴

# 2. TX와 GAS
## 1) TX의 목적은 블록체인의 상태를 변경하는 것
## 2) GAS는 TX를 처리하는데 발생하는 비용
### 이때 소모되는 비용을 Gas Fee라 정의
### Gas Fee는 블록을 생성한 노드가 수집

# 3. 트랜잭션과 서명
## 플랫폼은 sender가 TX가 처리되는데 필요한 가스피를 가지고 있는지 확인
## TX 체결과 동시에 sender의 balance에서 가스피를 차감
## TX는 sender의 서명(v, r, s)이 필요
### 1) 어카운트의 balance를 사용하기 때문
### 2) 서명의 증명은 구현마다 상이
#### ETH) 서명 → 공개키 도출 → 어카운트 주소 도출 → 어카운트 존재유무 확인
#### KLAY) From 주소 확인 → 저장된 공개키 불러오기 → 서명 직접 검증

# 4. 스마트 컨트랙트
## 특정 주소에 배포된 TX로 실행 가능한 코드
### 스마트 컨트랙트 소스코드는 함수와 상태를 표현 : 컨트랙트 소스코드는 블록체인 내 저장
### 함수는 상태를 변경하는 함수, 상태를 변경하지 않는 함수로 분류
### 사용자가 스마트 컨트랙트 함수를 실행하거나 상태를 읽을 때 주소가 필요
## 스마트 컨트랙트는 사용자가 실행
### 상태 변경 함수를 실행하려면 그에 맞는 TX를 생성해 블록에 추가(TX 실행 = 함수의 실행)

# 5. Solidity
## ETH / KLAY의 스마트컨트랙트 언어
## 포인터의 개념이 없기 때문에 Recursive Type의 선언이 불가능

## Contract = Code + Data
### Solidity 컨트랙트 코드(함수)와 데이터(상태)로 구성
### Solidity 함수는 코드 안에 변수로 선언된 상태를 변경하거나 불러옴
