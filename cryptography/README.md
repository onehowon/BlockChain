# 암호학
### 단일 문자 치환 암호 : 평문의 각 문자를 약속된 다른 문자로 치환하는 암호로 복호화를 위해 치환의 대응 관계는 일대일 대응이다. 평문의 'A'가 암호문의 'B'로 치환된다면, 평문의 다른 어떤 문자도 'B'로 치환되지 않습니다.
### 카이사르 암호 : 평문의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 치환한다. 이를 복호화할 때 암호문의 각 문자를 다시 원래 위치로 밀어서 평문을 구한다.(알파벳을 밀어낸 횟수만 알면 해독할 수 있다.)
#### 알파벳을 밀어낸 횟수를 키(Key)라고 한다면, 알파벳은 총 26자이므로 가능한 키의 갯수는 26개이다.
#### 암호학에서 가능한 모든 키의 집합을 키공간(Key Space)이라고 하는데, 이를 이용하여 다시 표현하면, 카이사르 암호에서 키 공간의 크기는 26이다.

### 다중 문자 치환 암호 : 단일문자 치환 암호와 달리, 평문의 한 문자가 암호문에서 여러 종류의 문자로 치환될수 있습니다. 대표적인 다중 문자 치환 암호로는 비제네르 암호가 있다.
### 전치 암호 : 평문을 구성하는 문자들의 순서를 재배열하여 암호문을 만든다. 평문을 정해진 길이의 블록들로 나누고, 규칙을 적용해 블록 안의 문자들을 재배치한다.

# 암호 시스템
### 혼돈 : 암호문에서 평문의 특성을 알아내기 힘든 성질
![image](https://user-images.githubusercontent.com/81984723/186636263-bcc340b4-84da-48c1-b359-0c2dd92147ef.png)
### 확산 : 평문의 작은 변화가 암호문의 큰 변화로 이어지는 성질
![image](https://user-images.githubusercontent.com/81984723/186636328-225f574c-f95b-4bba-9476-0c310ef468e2.png)
# 대칭키 암호 시스템
### 블록 암호 : 평문을 정해진 크기의 블록 단위로 암호화하는 암호
![image](https://user-images.githubusercontent.com/81984723/186636811-8babf789-38e5-4fda-97cc-ce61d2ae8fce.png)
#### 평문의 크기가 블록 크기의 배수가 아니어서 블록으로 균등하게 쪼갤 수 없다면, 평문뒤에 데이터를 추가하는 패딩(평문이 블록 크기의 배수가 될 때까지 데이터를 추가하는 것)을 수행한다.

### 스트림 암호 : 송신자와 수신자가 공유하는 데이터 스트림을 생성하고 이를 평문에 XOR하는 암호입니다. 평문을 P, 암호문을 C, 스트림을 X라고 할 때, 암호문 C는 C = P + X로 생성됩니다.
![image](https://user-images.githubusercontent.com/81984723/186636861-22347aaa-7429-4077-865d-689efb4d64f8.png)

## 대칭키 암호 시스템의 장점과 단점
#### 대칭키 암호 시스템은 일반적으로 공개키 암호 시스템에 비해 속도가 빠르지만, 송신자와 수신자가 사전에 키를 교환해야 한다는 제약이 있다.
#### 대칭키 암호 시스템에서는 그룹 내 여러 명이 존재할 경우 두 사람마다 다른 키를 생성해 사용해야 한다. 즉, N명의 사람이 존재할 때 총 N(N-1)/2개의 키가 필요하다.

# 공개키 암호 시스템
#### 송신자는 수신자의 공개키로 데이터를 암호화하여 수신자에게 전송하고, 수신자는 자신의 비밀키로 이를 복호화합니다.
#### 공개키는 모두에게 공개 돼있기에 누구나 수신자에게 암호문을 보낼 수 있으나 개인키는 수신자만 알기에, 공격자 암호문을 도청해도 이를 복호화 할 수 없음
#### 우체통 비유) 누구나 수신자 우체통으로 편지를 보낼 수 있으나, 꺼내 볼 수 있는 사람은 열쇠를 가진 수신자 뿐임

## 공개키 암호 시스템의 장점과 단점
#### 공개키 암호 시스템에서는 그룹 내 사람들이 각자 공개키와 비밀키를 만든 후 공개키만 공개하면 되므로 N명의 사람이 있을 때 2N개의 키만 필요하다. 이는 N(N-1)/2개의 키가 필요했던 대칭키 암호 시스템보다 훨씬 적다. 또한 한번 키를 생성시에 새로운 상대와 통신 하더라도 자신이 키를 다시 만들 필요가 없다.
#### 공개키 암호 시스템은 일반적으로 대칭키에 비해 복잡한 연산이 필요하므로 속도가 느리다. 또한 대칭키 암호와 같은 안전성을 제공하려면, 대칭키 암호보다 긴 키를 사용해야 한다.
#### 예를 들어 대칭키 암호 시스템인 AES는 192비트 이상의 키를 사용하면 충분히 안전하나, 공개키 암호 시스템인 RSA는 2048비트 이상의 키를 사용할 것이 권장된다.

# AES
## SPN(Substitution Permutation Network)
#### 곱 암호의 일종으로 S-BOX를 사용하는 치환과 P-BOX를 사용하는 순열을 여러 라운드에 걸쳐 반복한다.
![image](https://user-images.githubusercontent.com/81984723/187123447-a136de3a-db0a-4d03-ad44-65a1202fb93e.png)
#### 페이스텔 구조와는 달리 두 배의 암호학적 안전성을 가짐

## AES
#### 라운드마다 128비트 크기의 블록을 암호화는 블록 암호
#### 키의 길이는 128, 192, 256 비트 중 하나를 선택 가능하고, 라운드 수는 키의 길이에 따라 10,12,14로 결정
#### 256비트면 AES-256이라고 부름
#### EX) 입력이 1F3CF203B211C5AA6EB27A45E4D98130라면
![image](https://user-images.githubusercontent.com/81984723/187123676-d40246fe-af77-4bea-9028-67c283cea65d.png)
#### 이후 재구성된 입력에 대해 AddRoundKey 함수를 적용하고, 마지막 라운드 전까지 매 라운드마다 SubBytes, ShiftRows, MixColums, AddRoundKey 함수를 반복하여 적용
#### AES 라운드 함수들은 역함수가 존재하므로, 역함수를 이용해 AES 복호화가 이루어짐

## AES 라운드 함수
### SubBytes
#### State의 각 바이트를 S-Box를 참조하여 치환하는 함수
#### 바이트의 상위 4비트가 행, 하위 4비트가 열을 결정한다.
![image](https://user-images.githubusercontent.com/81984723/187123952-a58bba54-906d-440c-8c9c-2d7f3dbe8c5c.png)
![image](https://user-images.githubusercontent.com/81984723/187124026-578cf83f-741b-4c0c-892b-9f7a0ffc0088.png)

### ShiftRows
#### State의 각 행을 구성하는 바이트들을 쉬프트하는 함수이다.
#### 4가지 함수 중에서 유일하게 순열의 역할을 수행
#### 암호화 할 때, 2행은 왼쪽으로 1칸 3행은 왼쪽으로 2칸, 4행은 왼쪽으로 3칸을 민다.
#### 복호화 할 때, 2행,3행,4행을 각각 오른쪽으로 1칸,2칸,3칸씩 밉니다.
![image](https://user-images.githubusercontent.com/81984723/187124424-3120a241-1818-4f24-bbcb-f24b43f613ea.png)

### MixColumns
#### 열 단위로 치환을 수행하는 함수입니다. 치환은 갈루아 필드 내에서 행렬 연산으로 구해진다.
![image](https://user-images.githubusercontent.com/81984723/187125160-00ffdbd1-1e39-4699-9070-d61873c93c96.png)

### AddRoundKey
#### 키 생성 함수(Key Schedule)로 생성된 라운드 키의 state를 각 바이트별로 XOR합니다.
#### 복호화할 때 XOR의 성질을 이용해 동일한 키를 state에 XOR합니다.
![image](https://user-images.githubusercontent.com/81984723/187125305-f810f50a-1231-4fb0-a19d-9bb3963fe73e.png)

### Key Schedule
#### 키 생성 함수는 입력된 키로부터 각 라운드에 쓰일 라운드 키를 생성한다.

### RotWord
![image](https://user-images.githubusercontent.com/81984723/187125635-b4eeb7ea-078d-4549-a824-d43f125d99d5.png)

### SubWord
![image](https://user-images.githubusercontent.com/81984723/187125665-8cb1c0df-645d-48ac-a25a-5107b70f0673.png)

### Rcon
![image](https://user-images.githubusercontent.com/81984723/187125712-09688ee7-d096-4819-9e39-558c03759946.png)

# DES(Data Encryption Standard)
#### 56비트
#### 혼돈 성질을 만족하기 위해 치환, 확산 성질을 만족하기 위해 순열을 사용한다.

### 곱 암호
#### 각 라운드를 여러 번 반복하여 암호학적 안전성을 확보하는 암호
![image](https://user-images.githubusercontent.com/81984723/187126383-e49d12c4-821d-4d69-9f33-5fb6a42d4f09.png)

### 페이스텔 구조
![image](https://user-images.githubusercontent.com/81984723/187126669-1d066f64-2e73-4678-994b-d68073dec660.png)
#### 페이스텔 구조를 따르는 DES(1) 입력으로 들어온 블록을 동일한 길이의 왼쪽 블록 L과 오른쪽 블록 R로 나눈다.
#### (2) 각 라운드마다 오른쪽 블록은 다음 라운드 왼쪽 블록으로 입력된다.
#### (3) 왼쪽 블록은 오른쪽 블록에 라운드 함수 F를 적용한 결과와 xor되어 다음 라운드의 오른쪽 블록으로 입력된다.
#### 이를 정형화해서 나타내면 위 그림과 같다.
#### 여기서 P는 입력으로 들어온 평문을, K는 각 라운드에서 생성된 키를 말한다.

### 페이스텔 암호의 특징
#### 블록 암호는 평문을 복호화할 수 있어야 하므로, 암호화를 구성하는 각 함수에 역함수가 존재
#### 페이스텔 구조 사용시 F가 복호화 과정에서 상쇄되므로 역함수가 존재하지 않아도 됨
#### 암호화, 복호화의 구조가 동일하기에 라운드 키를 역순으로 입력하면 복호화가 이뤄진다.
![image](https://user-images.githubusercontent.com/81984723/187127224-dbfd4227-7780-45b6-81f2-e460c8dbe481.png)
#### Figure3에 따라 오른쪽 블록은 다음 라운드의 왼쪽 블록으로 어떠한 처리도 없이 입력된다.
#### 페이스텔 암호는 비페이스텔 암호와 같은 안전성을 갖기 위해 두 배 정도의 라운드를 사용해야 한다.

### 초기 순열, 최종 순열
#### DES는 시작할 때 초기 순열(Initial Permutation, IP)을 마지막에는 최종순열(Final Permutation, FP)을 수행한다.
#### 초기 순열과 최종 순열은 정해진 테이블을 이용해 64비트 입력을 비트 단위로 전치한다.
#### 테이블의 N번째 값이 m일 때 출력의 N번째 비트는 입력의 m번째 비트가 된다.

### 라운드 함수
#### 라운드 함수는 확장 순열(Expansion P-Box), 라운드 키 결합(XOR), 치환 테이블(S-Box) 그리고 고정 순열(Straight P-Box)로 이뤄져있다.

### 확장 순열
#### 입력을 비트 단위로 전치하는 동시에, 전체 길이를 48비트로 확장한다. 이 과정에서 32비트의 입력값을 4비트씩 8개 부분으로 나누고, 테이블을 참조해 6비트로 확장한다.
#### 테이블만 다를 뿐, 초기 순열, 최종 순열과 같은 방식으로 이뤄진다.
![image](https://user-images.githubusercontent.com/81984723/187127849-74aaede3-ea1a-40ee-8d91-152ba48f53d1.png)

### S-Box와 고정 순열
#### S-Box는 라운드 키 결합에서 출력된 48비트 결과 값을 32비트로 축소한다.
#### S-Box는 4개의 행과 16개의 열로 이뤄진 표를 사용하는데, 표의 각 값은 4비트로 표현되는 수이다.

### S-Box의 과정
#### (1) 입력을 여섯 비트씩 8개의 부분으로 나눈다.
#### (2) 여섯 비트 중 첫 번째와 마지막 비트로 행을 결정하고, 나머지 네 개의 비트로 열을 결정한다.
#### (3) S-Box의 표에서 행과 열을 참조해 값을 반환한다.
![image](https://user-images.githubusercontent.com/81984723/187128045-9c65f7a0-a6ab-4e8e-9694-6ecc51996eff.png)

### 키 생성 함수
#### 64비트의 입력을 받아 각 라운드에 필요한 48비트 라운드 키를 생성하는 함수
#### 패리티 비트 제거(Parity Bit Drop), 쉬프트(Shift), 압축순열(Compression P-Box)

### 패리티 비트 제거
#### 패리티 비트를 제거하고, 남은 56비트에 순열을 적용하는 과정
#### 각 바이트의 가장 오른쪽 비트는 자신이 속한 바이트의 나머지 7비트에 대한 홀수 패리티 비트이다.
#### 예를 들어 1010101에는 1이 4개인데, 홀수 패리티 비트를 적용하면 끝에 비트 1을 덧붙여, 10101011을 전송해야 한다.
![image](https://user-images.githubusercontent.com/81984723/187128280-16c02ab9-d3c4-4509-8f24-9248ab4aa7b2.png)
